runconfig:
    name: str()

    groups:
        PGENameGroup:
            PGEName: enum('INSAR_L_PGE')

        InputFileGroup:
            # REQUIRED - One NISAR L1B RSLC formatted HDF5 file
            InputFilePath: list(str(), min=2, max=2)

        DynamicAncillaryFileGroup:
            # Digital elevation model
            DEMFile: str()

        ProductPathGroup:
            # Directory where PGE will place results
            ProductPath: str()

            # Directory where SAS can write temporary data
            ScratchPath: str()

            # Intermediate file name.  SAS writes output product to the following file.
            # After the SAS completes, the PGE wrapper renames the product file
            # according to proper file naming conventions.
            # In INSAR mode, GUNW, RIFG, and RUNW will be prepended to SASOutputFile
            SASOutputFile: str()

        PrimaryExecutable:
            # RIFG_RUNW_GUNW will produce all three InSAR products
            ProductType: enum('GUNW', 'RIFG', 'RUNW', 'RIFG_RUNW_GUNW')

        DebugLevelGroup:
            DebugSwitch: bool()

        #adt section - isce3 + pyre workflow
        processing:
            # flag to keep or delete scratch contents
            keep_scratch: bool()

            # Mechanism to select frequencies and polarizations
            input_subset:
                # List of frequencies to process. Default empty representing all
                list_of_frequencies:
                    # valid values for polarizations
                    # empty for all polarizations found in RSLC
                    # [polarizations] for list of specific frequency(s) e.g. [HH, HV] or [HH]
                    A: any(list(str(min=2, max=2), min=1, max=4), str(min=2, max=2), null(), required=False)
                    B: any(list(str(min=2, max=2), min=1, max=4), str(min=2, max=2), null(), required=False)

            # Only checked when internet access is available
            dem_download:
                # s3 bucket / curl URL / local file
                source: str(required=False)
                top_left:
                    x: num(required=False)
                    y: num(required=False)

                bottom_right:
                    x: num(required=False)
                    y: num(required=False)


            # Mechanism to specify output posting and DEM
            geocode:
                # Required for geocode standalone
                runw_path: str(required=False)

                # DEM interpolation method. BILINEAR is default.
                interp_method: enum('BILINEAR', 'BICUBIC', 'NEAREST', 'BIQUINTIC', required=False)

                datasets: include('gunw_datasets', required=False)

                # Same as input DEM if not provided.
                outputEPSG: int(min=1024, max=32767, required=False)

                # Output posting in same units as output EPSG.
                # If not provided, spacing values will be taken from provided DEM.
                output_posting:
                    A:
                        x_posting: num(min=0, required=False)
                        y_posting: num(min=0, required=False)
                    B:
                        x_posting: num(min=0, required=False)
                        y_posting: num(min=0, required=False)

                # To control output grid in same units as output EPSG
                x_snap: num(min=0, required=False)

                # To control output grid in same units as output EPSG
                y_snap: num(min=0, required=False)

                top_left:
                    # Set top-left y in same units as output EPSG
                    y_abs: num(required=False)

                    # Set top-left x in same units as output EPSG
                    x_abs: num(required=False)

                bottom_right:
                    # Set bottom-right y in same units as output EPSG
                    y_abs: num(required=False)

                    # Set bottom-right x in same units as output EPSG
                    x_abs: num(required=False)

            radar_grid_cubes:  include('radar_grid_cubes_options', required=False)

            geo2rdr: include('geo2rdr_options', required=False)

            blocksize:
                y: int(min=100, max=10000)

            dem_margin: num(required=False)

            resample:
                lines_per_tile: int(min=1, required=False)


            dense_offsets: include('dense_offsets_options', required=False)

            rubbersheet: include('rubbersheet_options', required=False)

            crossmul: include('crossmul_options', required=False)

            # Required for RUNW and full InSAR
            phase_unwrap: include('icu_options', required=False)

        # To setup type of worker
        worker:
            # To prevent downloading DEM / other data automatically. Default True
            internet_access: bool(required=False)

            # To explicitly use GPU capability if available. Default False
            gpu_enabled: bool(required=False)
            # Index of the GPU to use for processing, optional. Defaults to the
            # first available CUDA device. Ignored if *gpu_enabled* is False.
            gpu_id: int(min=0, required=False)

        QA: include('qa_options', required=False)

        # Place holder for user set path to log file.
        # If not set, log sent to screen or input yaml path derived file
        logging: include('log_nfo', required=False)

---
icu_options:
    crossmul_path: str(required=False)
    seed: int(min=0, required=False)
    buffer_lines: int(min=1, required=False)
    overlap_lines: int(min=1, required=False)
    use_phase_gradient_neutron: bool(required=False)
    use_intensity_neutron: bool(required=False)
    phase_gradient_window_size: int(min=1, required=False)
    neutron_phase_gradient_threshold: num(min=0, required=False)
    neutron_intensity_threshold: num(min=0, required=False)
    max_intensity_correlation_threshold: num(required=False)
    trees_number: int(min=1, required=False)
    max_branch_length: int(min=1, required=False)
    pixel_spacing_ratio: num(required=False)
    initial_correlation_threshold: num(min=0, max=1, required=False)
    max_correlation_threshold: num(max=1, required=False)
    correlation_threshold_increments: num(min=0, max=1, required=False)
    min_tile_area: num(required=False)
    bootstrap_lines: int(min=1, required=False)
    min_overlap_area: int(min=0, required=False)
    phase_variance_threshold: num(min=0, required=False)

dense_offsets_options:
    # Flag to enable/disable dense offsets estimation. Default: True
    enabled: bool(required=False)
    # Path to HDF5 file or directory with geometry-coregistered SLCs.
    # Not required as we allow the use of intermediate outputs from
    # the previous InSAR module, which is not user-specified
    coregistered_slc_path: str(required=False)
    # Number of columns for chip/template window in reference image
    window_range: int(min=16, max=512, required=False)
    # Number of lines for chip/template window in reference image
    window_azimuth: int(min=16, max=512, required=False)
    # Number of columns for search chip/template in secondary image
    half_search_range: int(min=4, max=32, required=False)
    # Number of lines for search chip/template in secondary image
    half_search_azimuth: int(min=4, max=32, required=False)
    # Number of columns to skip in reference image for next offset estimate
    skip_range: int(min=1, required=False)
    # Number of lines to skip in reference image for next offset estimate
    skip_azimuth: int(min=1, required=False)
    # Margin around image edges to avoid for offset computation
    margin: int(min=0, required=False)
    # Number of columns of output offset (covariance, snr) file
    offset_width: int(required=False)
    # Number of lines of output offset (covariance, snr) file
    offset_length: int(required=False)
    # Start pixel of the reference image along slant range
    start_pixel_range: int(min=0, required=False)
    # Start pixel of the reference image along azimuth
    start_pixel_azimuth: int(min=0, required=False)
    # Domain (frequency or spatial) where to compute cross-correlation
    cross_correlation_domain: enum('frequency', 'spatial', required=False)
    # Anti-aliasing oversampling factor to apply to reference/secondary SLC
    # prior to cross-correlation computation
    slc_oversampling_factor: int(min=2, max=5, required=False)
    # Deramp data prior to FFT: magnitude or complex (linear phase ramp)
    deramping_method: enum('magnitude', 'complex', required=False)
    # Flag to use constant range/azimuth offsets in dense offsets estimation
    use_gross_offsets: bool(required=False)
    # Constant offset along slant range to guide dense offset estimation
    gross_offset_range: int(required=False)
    # Constant gross offset along az to guide dense offset estimation
    gross_offset_azimuth: int(required=False)
    # File path to pixel by pixel gross offset (e.g. from reference velocity map)
    gross_offset_filepath: str(required=False)
    # Flag to add gross offset to the output of dense offset file
    merge_gross_offset: bool(required=False)
    # Square zoom window size for cross-correlation statistics (SNR, covariance)
    correlation_statistics_zoom: int(required=False)
    # Square zoom window size for sub-pixel offset refinement
    correlation_surface_zoom: int(min=4, required=False)
    # Oversampling factor of the correlation surface for sub-pixel offset refinement
    correlation_surface_oversampling_factor: int(min=2, max=128, required=False)
    # Correlation surface oversampling algorithm
    correlation_surface_oversampling_method: enum('sinc', 'fft', required=False)
    # Number of cuda streams
    cuda_streams: int(required=False)
    # Number of offset estimates to process in batch along slant range
    windows_batch_range: int(min=1, required=False)
    # Number of offset estimates to process in batch along azimuth
    windows_batch_azimuth: int(min=1, required=False)

rubbersheet_options:
    # Path to dense offsets outputs (offsets, snr, covariance).
    # Not required as InSAR workflow allows using intermediate outputs
    # from previous steps (not user-specified)
    dense_offsets_path: str(required=False)
    # Path to geo2rdr offset path
    geo2rdr_offsets_path: str(required=False)
    # Flag to enable/disable rubbersheet step
    enabled: bool(required=False)
    # Metric used to identify offsets outliers
    culling_metric: enum('snr', 'median_filter', 'covariance', required=False)
    # Size of median filter in range. Median filter is used
    # for offset outlier identification.
    median_filter_size_range: int(min=3, required=False)
    # Size of median filter in azimuth (see above)
    median_filter_size_azimuth: int(min=3, required=False)
    # Threshold for outlier identification. Depends on "culling_metric".
    # SNR: offsets with SNR below threshold are identified as outliers
    # Covariance: offsets with range/azimuth covariance above threshold are outliers
    # Median filter: offsets with median absolute deviation above thresholds are outliers
    threshold: num(min=0, required=False)
    # Flag to enable mask refinement The intent of this refinement is to remove
    # noisy spots on 1-2 pixels after the first outlier identification.
    # The refinement is performed by thresholding the median absolute deviation of
    # the offsets where outlier locations have been filled with zeros
    mask_refine_enabled: bool(required=False)
    # Threshold for outlier refinement mask computation
    mask_refine_threshold: num(min=0, required=False)
    # Size of median filter in range and azimuth for outlier mask refinement
    mask_refine_filter_size: int(min=3, max=7, required=False)
    # Method to fill data holes left by outliers culling:
    # fill_smoothed: iteratively fill holes with mean value in a neighborhood.
    # nearest_neighbor: Fill holes with nearest neighbor interpolation
    outlier_filling_method: enum('fill_smoothed', 'nearest_neighbor', required=False)
    # Fill smoothed option
    fill_smoothed: include('fill_smoothed_options', required=False)
    # Interpolation method. Interpolation is used to fill residual
    # outlier holes (if present)
    interpolation_method: enum('nearest', 'linear', 'cubic', required=False)
    # It is good practice to filter the offsets prior to interferogram
    # formation to reduce noise. We expose: no_filter: do not filter the offsets/
    # degrade offsets resolution. median_filter, boxcar_filter (moving average),
    # gaussian_filter
    offsets_filter: enum('none', 'median', 'boxcar', 'gaussian', required=False)
    median: include('offset_filter_options', required=False)
    boxcar: include('offset_filter_options', required=False)
    gaussian: include('gaussian_filter_options', required=False)

fill_smoothed_options:
    # Number of fill smoothed iterations
    iterations: int(min=1, required=False)
    # Size of neighborhood where to look for smoothed values
    kernel_size: int(min=3, required=False)

offset_filter_options:
    # Filter size (median/boxcar) in slant range
    filter_size_range: int(min=3, required=False)
    # Filter size (median/boxcar) in azimuth
    filter_size_azimuth: int(min=3, required=False)

gaussian_filter_options:
    # Gaussian filter standard deviation
    sigma: int(min=0, required=False)

crossmul_options:
    # Path to HDF5 file or directory with coregistered SLCs
    # If directory then the following directory tree is required:
    # coregistered_slc_path
    # └── coregistered_secondary
    #      └── freq(A,B)
    #          └── (HH, HV, VH, VV)
    #              └── coregistered_secondary.slc
    coregistered_slc_path: str(required=False)
    range_looks: int(min=1,  required=False)
    azimuth_looks: int(min=1,  required=False)
    # Flatten is False disables flatten
    # Flatten is True runs flatten and sets data directory to scratch
    # Flatten is str assumes value is path to data directory
    # Data directory contains range offset rasters
    # The following directory tree is required:
    # flatten
    # └── geo2rdr
    #     └── freq(A,B)
    #         └── range.off
    # Flatten defaults to True
    flatten: any(bool(), str(min=1))
    oversample: int(min=1, required=False)
    rows_per_block: int(min=1, required=False)

radar_grid_cubes_options:

    # List of heights in meters
    heights: list(num(), required=False)

    # Same as input DEM if not provided.
    outputEPSG: int(min=1024, max=32767, required=False)
               
    # Output posting in same units as output EPSG.
    # If not provided, spacing values will be taken from provided DEM.
    output_posting:
        x_posting: num(min=0, required=False)
        y_posting: num(min=0, required=False)

    # To control output grid in same units as output EPSG
    x_snap: num(min=0, required=False)
               
    # To control output grid in same units as output EPSG
    y_snap: num(min=0, required=False)
               
    top_left:    
        # Set top-left y in same units as output EPSG
        y_abs: num(required=False)
       
        # Set top-left x in same units as output EPSG
        x_abs: num(required=False)
               
    bottom_right:  
        # Set bottom-right y in same units as output EPSG
        y_abs: num(required=False)
       
        # Set bottom-right x in same units as output EPSG
        x_abs: num(required=False)

geo2rdr_options:
    threshold: num(min=1.0e-9, max=1.0e-3, required=False)
    maxiter: int(min=10, max=50, required=False)
    topo_path: str(required=False)


log_nfo:
    # Path to log file
    path: str()
    # Log file write mode. 'a' for append to existing. 'w' for new or overwrite existing.
    write_mode: enum('a', 'w', required=False)

gunw_datasets:
    connectedComponents: bool(required=False)
    coherenceMagnitude: bool(required=False)
    unwrappedPhase: bool(required=False)


qa_options:
    # Enabled file format validation
    validate: bool(required=False)
    # Produce a data summary
    quality: bool(required=False)
