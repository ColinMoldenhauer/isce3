//-*- coding: utf-8 -*-
//
// Author: Piyush Agram
// Copyright 2019

/** @param[in] radarGrid RadarGridParameters object
    * @param[in] orbit     Orbit object
    * @param[in] lookSide  look direction of the radar
    * @param[in] doppler   LUT2d doppler model
    *
    * Alternative constructor from ellipsoid orbit and radarGrid.*/
isce::geometry::Rdr2GeoBoundingBox::
Topo(const isce::product::RadarGridParameters & radarGrid,
        const isce::core::Orbit & orbit,
        const isce::core::Ellipsoid & ellipsoid,
        const int lookSide,
        const isce::core::LUT2d<double> & doppler) :
        _orbit(orbit), _ellipsoid(ellipsoid),
        _doppler(doppler),_radarGrid(radarGrid), _lookSide(lookSide) {}


/** @param[in] t Distance threshold to flag convergence of iterations */
void isce::geometry::Rdr2GeoBoundingBox::
threshold(double t) {
    _threshold = t;
}

/** @param[in] n Number of primary iterations
 *
 * This is the number of iterations where solution of previous solution is directly used to initialize the next iteration*/
void isce::geometry::Rdr2GeoBoundingBox::
numiter(int n) {
    _numiter = n;
}

/** @param[in] method orbit interpolation method to use
 *
 * Set the orbit interpolation method while checking its validity*/
void isce::geometry::Rdr2GeoBoundingBox::
orbitMethod(isce::core::orbitInterpMethod method) {

    // Check validity
    if (method == isce::core::HERMITE_METHOD) {
        if (_orbit.nVectors < 4) {
            pyre::journal::error_t error("isce.geometry.Topo");
            error
                << pyre::journal::at(__HERE__)
                << "Error in BoundingBox::orbitMethod - Need at least 4 state vectors for using "
                << "hermite polynomial interpolation."
                << pyre::journal::endl;
        }
    } else if (method == isce::core::SCH_METHOD) {
        if (_orbit.nVectors < 4) {
            pyre::journal::error_t error("isce.geometry.Topo");
            error
                << pyre::journal::at(__HERE__)
                << "Error in BoundingBox::orbitMethod - Need at least 4 state vectors for using "
                << "SCH interpolation."
                << pyre::journal::endl;
        }
    } else if (method == isce::core::LEGENDRE_METHOD) {
        if (_orbit.nVectors < 9) {
            pyre::journal::error_t error("isce.geometry.Topo");
            error
                << pyre::journal::at(__HERE__)
                << "Error in BoundingBox::orbitMethod - Need at least 9 state vectors for using "
                << "legendre polynomial interpolation."
                << pyre::journal::endl;
        }
    } else {
        pyre::journal::error_t error("isce.geometry.Topo");
        error
            << pyre::journal::at(__HERE__)
            << "Error in BoundingBox::orbitMethod - Undefined orbit interpolation method."
            << pyre::journal::endl;
    }

    // Save
    _orbitMethod = method;
}

/** @param[in] n Points per edge
 *
 * This is the number of points to transform along each edge of the radar image*/
void isce::geometry::Rdr2GeoBoundingBox::
pointsPerEdge(int n) {
    _pointsPerEdge = n;
}

/** This returns the number of points expected to be returned by a transformation. Can be compared against length of returned results to confirm that all points were successfully transformed. */
int isce::geometry::Rdr2GeoBoundingBox::
numPerimeterPoints(){
    return (4 * _pointsPerEdge - 4);
}

// end of file
